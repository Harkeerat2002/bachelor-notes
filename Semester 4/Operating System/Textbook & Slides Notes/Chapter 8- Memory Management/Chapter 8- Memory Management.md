- **Task of Operating System:**
    - Which data from secondary memory should come to the main memory and at which location
    - CPU generates an address for data at secondary memory but has access to main memory, thus operating system performs the address translation.
- **Functions of Memory Management:**
    - **Keep track** of the status of each memory location whether the memory is allocated or free.
    - **Determining** allocation policy for the memory.
    - **Memory allocation techniques**, memory allocation information updating.
    - **Providing memory protection schemes** which are critical to accomplishing.
- Memory consists of a large array of bytes, each with its own address.
- CPU fetches instructions from memory according to the value of the program counter.
- **Typical Instruction-execution cycle FEDEX:**
    - **Fetches** an instruction from memory
    - **Decode** the instruction (it may cause operands to be fetched from memory)
    - After the instruction has been **executed** on the operands, results may be **stored** back in memory.
- The memory unit sees only a stream of memory addresses; it does not know how they are generated or what they are for.

## Basic Hardware:

- The **main memory** and **registers** built into each processing core are the only general-purpose storage that the CPU has access to directly.
- There are machine instructions that take memory addresses as arguments.

## Address Binding:

- Programs must be brought into memory and placed within a process queue for them to be run.
- Input queue or job queue - a collection of processes on the disk that are waiting to be brought into memory to run the program.
- User programs go through several steps before being executed.
- **Binding an address to the data or instruction of a process is called address binding.**
- It can be done at three points of time:
    - **Compile Time**
    - **Load Time**
    - **Run Time**

## Logical Address vs Physical Address

![[../../../../Attachments/Untitled 48.png|Untitled 48.png]]

- **Logical Address:** An address generated by the CPU is known as the Logical address or Virtual Address.
    - At compile time and load time binding, the logical address is the same as the physical address.
    - Different in execution time address binding scheme.
- **Physical Address:** The address seen by the memory unit that is the one loaded into the memory address register (MAR) of the memory is known as the physical address.
- While logical address and physical address are different at run time. Therefore, we need special hardware to convert the logical address into a physical address and that hardware unit is known as **Memory Management Unit (M.M.U).**
    - The value in the relocation register is added to every address generated by a user process at the time it is sent to memory.
    - The user program deals with logical addresses; it never sees the real physical addresses.
- **Dynamic Loading**
    - To obtain better memory-space utilization, we can use **dynamic loading.**
    - With dynamic loading, a routine is not loaded until it is called.

## Contiguous Allocation

- The memory is usually **divided into two partitions**: one for the **resident operating system**, and one for the **user processes.**
- In this contiguous memory allocation, **each process is contained in a single contiguous section of memory.**

### Memory **Protection:**

![[../../../../Attachments/Untitled 1 20.png|Untitled 1 20.png]]

- **Protection:**
    - Protection from one process to another.
    - Protection for OS routines.

### Single Partition Allocation:

- A relocation register scheme is used to protect user processes from each other, and from changing operating-system code and data.
- The relocation register contains the value of the smallest physical address; the limit register contains the range of logical addresses.
- Each logical address must fall within the range specified by the limit register.

![[../../../../Attachments/Untitled 2 16.png|Untitled 2 16.png]]

### Multiple Partition Allocation:

![[../../../../Attachments/Untitled 3 14.png|Untitled 3 14.png]]

- **Hole:** Block of available memory; holes of various sizes are scattered throughout memory.
- When a process arrives, it is allocated memory from a hole large enough to accommodate it.
- Operating System **maintains information** about:
    - **Allocation Partitions**
    - **Free Partitions**

### Dynamic Storage Allocation Problem:

- **Problem:**
    - _How to satisfy a request of size n from a list of free holes?_
- **First-fit:** Allocate the first hole that is big enough.
- **Best fit:** Allocate the smallest hole that is big enough; must search the entire list, unless ordered by size. Produces the smallest leftover hole.
- **Worst-fit:** Allocate the largest hole; must also search the entire list. Produces the largest leftover hole.

## Fragmentation:

- A process is loaded and removed from memory, the free memory space is broken into little pieces.
- After sometimes that process cannot be allocated to memory, because of its small size and the memory block remains unused.
- This problem is called **Fragmentation.**
- **External Fragmentation:**
    - Total memory space is enough to satisfy a request n reside a process in it, but it is not contiguous, so it cannot be used.
- **Internal Fragmentation:**
    - Allocated memory may be slightly larger than requested memory; this size difference is memory internal to a partition, but not being used.
- **Compaction:** Reducing external fragmentation
    - Shuffle memory contents to place all free memory together in one large block.
    - Compaction is possible only if relocation is dynamic, and is done at execution time

## Swapping:

![[../../../../Attachments/Untitled 4 13.png|Untitled 4 13.png]]

- It is a mechanism in which a process can be swapped **temporar**i**ly** out of main memory to secondary memory.
- Later it swaps back to the main memory.
- **Backing Store:** Fast fisk large enough to accommodate copies of all memory images for all users; must provide direct access to these memory images.
- A major part of swap time is **transfer time; total transfer time** is directly proportional to the amount of memory swapped.

## Paging

- Used in Non-Contiguous Allocation (Virtual Memory).
- **Virtual Memory is used to**:
    - Provide easy to the user
    - Increase in CPU utilization
- OS gives the **illusion** to the user such that:
    - Users can **write a very big program**.
    - The user thinks that is **entire program is present in the RAM**.
    - All the space **allocated** to the **user is contiguous**.
- In reality, only a small portion of the user program is in RAM, which may or may not be contiguous while the remaining is in the secondary memory.
- A computer can add more memory th**a**n the amount which is physically installed on the system is called **Virtual Memory.**
- **Paging** is a memory management technique in which the process adds space and is broken into blocks of the same size is called **paging** (power of 2).
- **Divide Physical Memory** into fixed-size blocks called **frames.**
- **Divide logical memory** into blocks of the same size called **pages.**
- Since the size of the frame is equal to the size of the page, external fragmentation is avoided.

### Address Translation Scheme

![[../../../../Attachments/Untitled 5 13.png|Untitled 5 13.png]]

- The **page address is called the logical address** and is represented by:
    - _Logical Address = Page Number + Page Offset_
- The **frame address is called the physical address** and is represented by:
    - _Physical Address = Frame Number + Page Offset_
- In this scheme, every data/instruction access requires two memory accesses: One for the page table and one for the data/instruction.
- The two memory access problems can be solved by the use of a special fast-lookup hardware cache called **associative memory** or **translation look-aside buffers (TLBS)**

### Associative Memory

![[../../../../Attachments/Untitled 6 12.png|Untitled 6 12.png]]

- **Address translation (A ́, A ́ ́)**
    - If A ́ is in the associative register, get the frame number out
    - Otherwise, get the frame number from the page table in  
        memory

### Memory Protection

![[../../../../Attachments/Untitled 7 10.png|Untitled 7 10.png]]

- Memory protection is implemented by associating the protection bit with each frame.
- **Valid-invalid** bit attached to each entry in the page table:
    - **Valid** indicates that the associated page is in the process’s logical address space, and is thus a legal page.
    - **Invalid** indicates that the page is not in the process’s logical address space.

### Shared Pages

- An advantage of paging is the possibility of sharing common code. This consideration is particularly important in a time-sharing environment.
- One copy of read-only (reentrant) code is shared among processes.
- Shared code must appear in the same location in the logical address space of all processes.

### Structure of the Page Table

- Very costly to store these entries in the physical address space.
- Do not want to allocate the page table contiguously in the main memory.
- **Solutions:**
    - **Hierarchical Paging**
        - Two-level paging Algorithm
            - The page table itself is also paged.
        - Break up the logical address space into multiple page tables.
    - **Hashed Page Tables**
        - Common in address spaced > 32 bits
        - The virtual page number (the hash value) is hashed into a page table
            - Each entry in the table is a linked list of elements hashing to the same location.
    - **Inverted Page Tables**
        - One entry for each real page of memory
        - The entry consists of the virtual address of the page stored in that real memory location, with information about the process that owns that page.

## Segmentation