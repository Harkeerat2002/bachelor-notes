# Chapter 09: Memory Management
## Background:
- **Program** must be brought into memory and placed within a process for it to be run.
- Main memory and registers are the only storage CPU can access directly
- Memory unit only sees a stream of:
	- addresses + read requests, or
	- address + data and write requests.
- Protection of memory required to ensure correct operation.
- Main memory can take many cycles, causing a **stall**.
- **Cache** sits between main memory and CPU registers.
>To execute a process, CPU fetches the instruction and data from addresses in memory
## Protection:
- Need to ensure that a process can access only those addresses in its address space.
- Can provide protection using, a pair of **base** and **limit registers**.
## Address Binding:
- Programs on disk, ready to be brought into memory to execute to form an **input queue**.
- #### Binding of Instructions and Data to Memory:
	- Address Binding refers to the **mapping** of computer instructions and data to physical memory locations.
	- Address binding of instructions and data to memory addresses can happen at three different stages:
		- **Compile Time:** 
			- If memory location is known prior, an *absolute code* can be generated; must recompile code if starting location changes.
			- The programs know from which address it is supposed to get loaded, and from where it is supposed to get executed.
			- ***Advantage:*** Minimum set-up time
			- ***Disadvantage***: If the memory space is preoccupied from a different process, it would be overridden.
		- **Load Time:** 
			- Must generate *relocatable code* if memory location is not known at compile time.
		- **Execution time:** 
			- *Binding Delayed* until run time if the process can be moved during its execution from one memory segment to another.
	- ![[../../../Attachments/Pasted image 20220621170956.png|300]]

## Memory Management UNI:
- ### Logical vs Physical Address Space:
	- **Logical Address:** generated by the CPU; also referred to as *virtual address*
	- **Physical Address:** address seen by the memory unit
	- ![[../../../Attachments/Pasted image 20220622145419.png|450]]
	- **Logical Address space:** is the set of all logical addresses generated by a program
	- **Physical Address space:** is the set of all physical addresses generated by a program.
- ![[../../../Attachments/Pasted image 20220622145716.png|450]]
- To covert the Logical address to physical address, MMU is needed.
- It is a hardware device which maps the *virtual address* to *physical address*.
- In MMU scheme, the value in the relocation register is *added* to every address generated by the user process at the time, it is sent to the memory.
- The *user process* always *deals* with the *logical address*. It never sees the *physical address*.
## Contiguous Memory Allocation:
- The memory is usually divided into two partitions:
	- One for the operating system
	- One for the user processes
- We usually want several user processes to reside in memory at the same time.
- In *contiguous memory allocation*, each process is contained in a single section of memory that is contiguous to the section containing the next process.
- ### Memory Protection:
	- Two ways to prevent a process from accessing memory that it does not own.
	- Using a relocation register, together with a limit register:
		- Relocation register contains the value of the smallest physical address.
		- Limit register contains the range of logical addresses.
	- Each logical address must be less than the limit register.
- The simplest methods of allocating memory are to assign processes to variably sized partitions in memory, where each partition may contain exactly one process.
- ### Variable Partition:
	- ![[../../../Attachments/Pasted image 20220622152458.png| 450]]
	- In **Variable Partition** scheme, the operating system keeps a table indicating which parts of memory are available and which are occupied.
	- Initially, all memory is available for user processes and is considered one large block of available memory, a *hole*.
	- *Hole:* Block of available memory. 
	- Operating system maintain information about:
		- Allocated partitions
		- Free partitions
- ### Dynamic Storage - Allocation Problem:
	- **First-Fit:** Allocate the first hole that is big enough
	- **Best-Fit:** Allocate the smallest hole that is big enough; must search entire list, unless ordered by size. Produces the smallest leftover hole.
	- **Worst-Fit:** Allocate the largest hole; must also search entire list. Produces the largest leftover hole.
- ### Fragmentation:
	- **External Fragmentation:** total memory space exists to satisfy a request, but it is not contiguous
	- **Internal Fragmentation:** allocated memory may be slightly larger than requested memory; this size difference is memory internal to a partition, but not being used
	- **Compaction:** reducing external fragmentation by compaction.
		- Shuffle memory contents to place all free memory together in one large block.
		- Compaction is possible only if relocation is dynamic, and is done at execution time.
- ### Swapping:
	- ![[../../../Attachments/Pasted image 20220622153300.png| 450]]
	- A process can be swapped temporarily out of memory to a backing store, and then brought back into memory for continued execution.
	- **Backing Store:** Fast disk large enough to accommodate copies of all memory images for all users; must provide direct access to these memory images.
## Non-contiguous Memory Allocation:
- ### Paging:
	- Logical address space of a process can be noncontiguous; process is allocated physical memory whenever the latter is available  
	- Divide physical memory into fixed-sized blocks called frames (size is power of 2, between 512 bytes and 8K bytes)  
	- Divide logical memory into blocks of same size called pages.  
	- Keep track of all free frames  
	- To run a program of size n pages, need to find n free frames and load program  
	- Set up a page table to translate logical to physical addresses  
	- Internal fragmentation 
	- #### Address Translation Scheme:
		- Address generated by CPU is divided into:
			- **Page number (p)** – used as an index into a page table which contains base address of each page in physical memory
			- **Page offset (d)** – combined with base address to define the physical memory address that is sent to the memory unit
- ### Memory Protection:
	- Memory protection implemented by associating protection bit with each frame.
	- **Valid-invalid** bit attached to each entry in the page table.
		- *Valid* indicates that the associated page is in the process logical address space, and is thus a legal page.
		- *Invalid* indicates that the page is not in the process logical address space.
- ### Page Table Structure:
	- **Hierarchical Paging:**
		- Break up the logical address space into multiple page tables.
		- A simple technique is a two-level page table.
	- **Hashed Page Tables:**
		- The virtual page number is hashed into a page table.
		- This page table contains a chain of elements hashing to the same location.
		- Virtual page numbers are compared in this chain, searching for a match.
		- If a match is found, the corresponding physical frame is extracted.
	- **Inverted Page Tables:**
		- One entry for each real page of memory.
		- The entry consists of the virtual address of the page stored in that real memory location, with information about the process that owns that page.